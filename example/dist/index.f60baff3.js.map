{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-1606790850ec2415.js","../nom-reprap-response-wasm/pkg/web.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","node_modules/@parcel/runtime-js/lib/runtime-95a648ffbaec493c.js","../browser-gcode-sender/dist/index.js","index.js"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"hclZX\\\":\\\"index.f60baff3.js\\\",\\\"89ULf\\\":\\\"web_bg.143a1c7b.wasm\\\"}\"));","\nlet wasm;\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n* @param {string} input\n* @returns {any}\n*/\nexport function parseResponse(input) {\n    var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.parseResponse(ptr0, len0);\n    return takeObject(ret);\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('web_bg.wasm', import.meta.url);\n    }\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_json_parse = function(arg0, arg1) {\n        var ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_693216e109162396 = function() {\n        var ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {\n        var ret = getObject(arg1).stack;\n        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {\n        try {\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(arg0, arg1);\n        }\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n\n    return wasm;\n}\n\nexport default init;\n\n","\"use strict\";\n\nvar bundleURL = {};\n\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n\n  return value;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","module.exports = require('./helpers/bundle-url').getBundleURL('hclZX') + require('./helpers/bundle-manifest').resolve(\"89ULf\");","import initWASM, { parseResponse } from '@d1plo1d/nom-reprap-response-wasm';\n\nconst checksum = (line) => {\n  let sum = 0\n  for (const char of line) {\n    sum ^= char.charCodeAt(0)\n  }\n  sum &= 0xff\n  return sum\n}\n\nconst connectSerial = async ({\n  baudRate,\n  reuseSerialPort = false,\n}) => {\n    // Get previously connected ports so we don't need to re-prompt the user\n    const ports = await navigator.serial.getPorts()\n    // const ports = [];\n\n    let port;\n    if (ports.length > 0 && reuseSerialPort) {\n      console.log('Reconnecting to previously selected serial port');\n      port = ports[0];\n    } else {\n      // Prompt user to select any serial port.\n      port = await navigator.serial.requestPort({\n        // filters: [{\n        //   // Hardcoded to the Ender 3's product ID for testing. Comment out this line to show all\n        //   // ports.\n        //   usbVendorId: '0x0403',\n        // }],\n      });\n      console.log('Connecting to new serial port');\n    }\n\n    await port.open({ baudRate });\n\n    const textEncoder = new TextEncoderStream();\n    textEncoder.readable.pipeTo(port.writable);\n    const writer = textEncoder.writable.getWriter();\n\n    const textDecoder = new TextDecoderStream();\n    port.readable.pipeTo(textDecoder.writable);\n    const reader = textDecoder.readable.getReader();\n\n    return { reader, writer };\n}\n\nexport const print = async ({\n  baudRate,\n  gcodes,\n  onReceive = (_value) => {},\n  onSend = (_value) => {},\n  reuseSerialPort = false,\n}) => {\n  let readBuffer = \"\";\n  let pauseResumePromise = null;\n  let pauseResumeResolveFn = null;\n  let currentLine = 0;\n\n  await initWASM();\n  const { reader, writer } = await connectSerial({\n    baudRate,\n    reuseSerialPort,\n  });\n\n  const gcodeLines = gcodes\n    .split('\\n')\n    .map(line => line.trim())\n    // Remove comments and empty lines\n    .filter(line => !line.startsWith(';') && !line.startsWith('(') && line.length !== 0);\n\n\n  // Reads until a full message is received from the printer\n  const waitForResponse = async (filter) => {\n    while (true) {\n      // Read responses from the buffer first in case there are responses already ready to parse\n      let endOfBuffer = false;\n      while (!endOfBuffer) {\n        // console.log('parse', readBuffer);\n\n        let {\n          remainder,\n          response,\n        } = parseResponse(readBuffer);\n\n        readBuffer = remainder\n\n        if (response != null) {\n          // console.log(response)\n\n          if (response.type === 'error') {\n            throw new Error(`Firmware Error: ${response.content}`)\n          }\n\n          if (filter?.types?.includes(response.type)) {\n            return response\n          }\n        }\n\n        if (response == null) {\n          endOfBuffer = true\n        }\n      }\n\n      // Then await more data from the serial port\n\n      // console.log('attempting read...')\n      let newChars = ''\n      do {\n        const { value, done } = await reader.read();\n\n        if (done) {\n            // Allow the serial port to be closed later.\n            //reader.releaseLock();\n            throw new Error('Serial port closed');\n        }\n\n        // readBuffer = readBuffer.concat(value)\n        readBuffer = `${readBuffer}${value}`\n        newChars = `${newChars}${value}`\n      } while (!readBuffer.endsWith('\\n'))\n      onReceive(newChars);\n    };\n  };\n\n  let nextLineNumber = 1;\n  let isStopped = false\n\n  const normalizeGCode = ( gcode, { sendLineNumber }) => {\n    let line = gcode;\n    // Remove comments so they don't clober checksums\n    line = line.replace(/;.+/, '');\n\n    if (sendLineNumber === true) {\n      let lineNumber = nextLineNumber;\n      nextLineNumber += 1;\n\n      line = `N${lineNumber} ${line}`\n    }\n\n    return `${line}*${checksum(line)}\\n`\n  }\n\n  const sendGCode = async (gcode, { sendLineNumber = true } = {}) => {\n    const line = normalizeGCode(gcode, { sendLineNumber });\n    onSend({\n      lineNumber: nextLineNumber -1,\n      totalLines: gcodeLines.length,\n      line,\n    })\n\n    // console.log('GCode sent', line)\n    await writer.write(line);\n\n    const response = await waitForResponse({ types: ['ok'] })\n    // console.log('GCode response received', response);\n\n    return response;\n  }\n\n  const completionPromise = (async () => {\n    // Printer startup\n    const response = await waitForResponse({ types: ['greeting', 'ok'] });\n    console.log('Recevied greeting', response);\n\n    // Reset the line number\n    await sendGCode('M110 N0', { sendLineNumber: false });\n\n    // Run the print\n    for (gcode of gcodeLines) {\n      if (isStopped) {\n        return;\n      }\n\n      if (pauseResumePromise != null) {\n        await pauseResumePromise\n      }\n\n      currentLine += 1;\n      await sendGCode(gcode);\n    };\n  })();\n\n  return {\n    _inner: { reader, writer },\n    totalLines: gcodeLines.length,\n    getCurrentLine: () => currentLine,\n    completionPromise,\n    stop: () => {\n      isStopped = true\n    },\n    pause: () => {\n      pauseResumePromise = new Promise((resolve) => {\n        pauseResumeResolveFn = resolve;\n      });\n    },\n    resume: () => {\n      pauseResumePromise = null;\n      pauseResumeResolveFn();\n    },\n  }\n}\n","import { print } from '@d1plo1d/browser-gcode-sender'\n\nconst appendToTerminal = ({ div, value }) => {\n  div.innerHTML += value;\n\n  if (div.innerHTML.length > 3000) {\n    div.innerHTML = div.innerHTML.slice(div.innerHTML.length - 3000);\n  }\n\n  //scroll down to bottom of div\n  div.scrollTop = div.scrollHeight;\n}\n\nconst run = async () => {\n  let start = performance.now();\n\n  const runButton = document.getElementById(\"runButton\");\n  const serialResultsDiv = document.getElementById(\"serialResults\");\n  const percentageCompleteDiv = document.getElementById(\"percentageComplete\");\n  const fileInput = document.getElementById(\"gcodeFile\");\n\n  const baudRate = document.querySelector('#baudRate').value;\n\n  const file = fileInput.files[0];\n\n  if (file == null) {\n    alert(\"Please select a GCode file before starting the print\")\n    return\n  }\n\n  runButton.setAttribute('disabled', true);\n\n  console.log('Starting print...')\n\n  // const gcodes = `\n  //   ; Home the printer\n  //   G28\n  //   G90\n  //   G1 F3000\n  //   ; Move X\n  //   G1 X100 F3000\n  //   ; Move Y\n  //   G1 Y100 F3000\n  //   ; Move X\n  //   G1 X0 F3000\n  //   ; Move Y\n  //   G1 Y0 F3000\n  // `\n  //   .replace(/\\n\\s+/g, '\\n');\n\n  const gcodes = await fileInput.files[0].text();\n\n  const {\n    // totalLines,\n    // getCurrentLine,\n    completionPromise,\n    // stop,\n    // pause,\n    // resume,\n  } = await print({\n    gcodes,\n    baudRate,\n    reuseSerialPort: true,\n    onReceive: (value) => {\n      appendToTerminal({\n        div: serialResultsDiv,\n        value: value.split('\\n').filter(l => l.length > 0).map(line => `RX: ${line}\\n`).join(''),\n      });\n    },\n    onSend: ({ lineNumber, totalLines, line}) => {\n      appendToTerminal({\n        div: serialResultsDiv,\n        value: `TX: ${line}`,\n      });\n      percentageCompleteDiv.innerText = `${(lineNumber / totalLines * 100).toFixed(1)}%`\n    },\n  });\n\n  await completionPromise;\n\n  runButton.setAttribute('disabled', false);\n\n  console.log(`Done JS Execution in ${performance.now() - start}ms`);\n}\n\nwindow.run = () => run().catch(e => console.error(e));\n"],"names":["$8b4d1930797b255e$export$6503ec6e8aabbaf","$8b4d1930797b255e$export$f7ad0328861e2f03","$8b4d1930797b255e$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","$9252d01ef925c1a5$var$wasm","$9252d01ef925c1a5$var$cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","$9252d01ef925c1a5$var$cachegetUint8Memory0","$9252d01ef925c1a5$var$getUint8Memory0","buffer","memory","Uint8Array","$9252d01ef925c1a5$var$getStringFromWasm0","ptr","len","subarray","$9252d01ef925c1a5$var$heap","Array","fill","undefined","push","$9252d01ef925c1a5$var$heap_next","$9252d01ef925c1a5$var$addHeapObject","obj","idx","$9252d01ef925c1a5$var$getObject","$9252d01ef925c1a5$var$takeObject","ret","$9252d01ef925c1a5$var$dropObject","$9252d01ef925c1a5$var$WASM_VECTOR_LEN","$9252d01ef925c1a5$var$cachedTextEncoder","TextEncoder","$9252d01ef925c1a5$var$encodeString","encodeInto","arg","view","buf","encode","set","read","written","$9252d01ef925c1a5$var$passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","$9252d01ef925c1a5$export$ba14d9a5a581e827","input","ptr0","__wbindgen_malloc","__wbindgen_realloc","len0","parseResponse","$9252d01ef925c1a5$var$cachegetInt32Memory0","$9252d01ef925c1a5$var$getInt32Memory0","Int32Array","$f29cd6c67ea13581$export$bdfd709ae4826697","$f29cd6c67ea13581$var$bundleURL","$f29cd6c67ea13581$var$getBaseURL","url","replace","value","err","matches","stack","match","$f29cd6c67ea13581$var$getBundleURL","$99d1ce7ecaf78f9d$exports","getBundleURL","resolve","$9252d01ef925c1a5$export$2e2bcd8739ae039","$9252d01ef925c1a5$var$init","URL","imports","wbg","__wbindgen_json_parse","arg0","arg1","__wbg_new_693216e109162396","__wbg_stack_0ddaca5d1abfb52f","__wbg_error_09919627ac0992f5","console","error","__wbindgen_free","__wbindgen_object_drop_ref","Request","fetch","instance","module","Response","WebAssembly","instantiateStreaming","e","headers","get","warn","bytes","arrayBuffer","instantiate","Instance","$9252d01ef925c1a5$var$load","exports","__wbindgen_wasm_module","$148821d7f9e01bb7$var$$4fa0c73a46e81912$export$c2d084dc44961371","async","baudRate","gcodes","onReceive","_value","onSend","reuseSerialPort","readBuffer","pauseResumePromise","pauseResumeResolveFn","currentLine","$148821d7f9e01bb7$var$$parcel$interopDefault","$9252d01ef925c1a5$exports","reader","writer","ports","navigator","serial","getPorts","port","log","requestPort","open","textEncoder","TextEncoderStream","readable","pipeTo","writable","getWriter","textDecoder","TextDecoderStream","getReader","$148821d7f9e01bb7$var$$4fa0c73a46e81912$var$connectSerial","gcodeLines","split","map","line","trim","filter","startsWith","waitForResponse","endOfBuffer","remainder","response","type","content","types","includes","newChars","done","endsWith","nextLineNumber","isStopped","sendGCode","gcode","sendLineNumber","lineNumber","sum","char","$148821d7f9e01bb7$var$$4fa0c73a46e81912$var$checksum","normalizeGCode","totalLines","write","completionPromise","_inner","getCurrentLine","stop","pause","Promise","resume","$a501d8345a242c58$var$appendToTerminal","div","innerHTML","scrollTop","scrollHeight","window","run","start","performance","now","runButton","document","getElementById","serialResultsDiv","percentageCompleteDiv","fileInput","querySelector","files","alert","setAttribute","text","$148821d7f9e01bb7$exports","print","l","join","innerText","toFixed","$a501d8345a242c58$var$run","catch"],"version":3,"file":"index.f60baff3.js.map"}